// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/12/Memory.jack

/**
 * This library provides two services: direct access to the computer's main
 * memory (RAM), and allocation and recycling of memory blocks. The Hack RAM
 * consists of 32,768 words, each holding a 16-bit binary number.
 */ 
class Memory {
    static Array arr;
    static int heapBase;
    static int heapSize;
    static int freeList;

    /** Initializes the class. */
    function void init() {
        let arr = 0;
        let heapBase = 2048;
        //let heapSize = 10;
        let heapSize = 14336;  // from [2048, 16384)
        let freeList = heapBase;  // also by default freeList[0] -> NULL
        do Memory.poke(freeList+1, heapSize - 2);
        return;
    }

    /** Returns the RAM value at the given address. */
    function int peek(int address) {
        return arr[address];
    }

    /** Sets the RAM value at the given address to the given value. */
    function void poke(int address, int value) {
        let arr[address] = value;
        return;
    }

    /** Finds an available RAM block of the given size and returns
     *  a reference to its base address. */
    function int alloc(int size) {
        var int i, blockSize, block;

        // first fit of memory is returned.
        let i = freeList;
        while (~(i = 0)) {
            let blockSize = Memory.peek(i + 1);
            // need to find a block size at least with two cells
            // bigger than the requesting size, to keep bookkeeping
            // info of next pointer and block size in those two cells
            // of the returning block.
            if ((blockSize - size) > 1) {
                // we've consumed size + 2 out of blockSize of current
                // segment we're on, update its size.
                do Memory.poke(i + 1, blockSize - (size + 2));

                // where new block starts, out of which first two cells
                // keep track of next ptr and block size. We return block+2
                // to user.
                let block = i + (blockSize - size);
                do Memory.poke(block, 0);  // NULL as next of this block, just for sanity
                do Memory.poke(block + 1, size);
                return block + 2;
            }
            // try next block
            let i = Memory.peek(i);
        }

        // TODO, call defrag and retry?
        // Memory is full or fragmented.
        return -1;
    }

    /** De-allocates the given object (cast as an array) by making
     *  it available for future allocations. */
    function void deAlloc(Array o) {
        var int i;
        let i = freeList;
        // go to the end of the linked list of free segments.
        while (~(Memory.peek(i) = 0)) {
            let i = Memory.peek(i);
        }
        // puts last->next = block_address of object received
        do Memory.poke(i, o - 2);
        // set object->next = null.
        do Memory.poke(o - 2, 0);
        return;
    }
}
